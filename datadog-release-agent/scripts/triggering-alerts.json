{
  "schemaVersion": 1,
  "name": "triggering-alerts",
  "description": "",
  "language": "python",
  "code": "import json\nimport os\nimport sys\nimport urllib.request\nimport urllib.error\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nimport re\nfrom datetime import datetime, timezone\n\n\ndef _parse_rfc3339(time_str: str) -\u003e Optional[int]:\n    \"\"\"\n    Parse RFC3339 timestamp and return Unix timestamp in milliseconds.\n    Supports formats like: '2024-01-15T10:30:00Z', '2024-01-15T10:30:00+00:00'\n    \"\"\"\n    try:\n        # Try parsing with Z suffix\n        if time_str.endswith('Z'):\n            dt = datetime.fromisoformat(time_str.replace('Z', '+00:00'))\n        else:\n            dt = datetime.fromisoformat(time_str)\n        \n        # Convert to UTC if timezone-aware\n        if dt.tzinfo is not None:\n            dt = dt.astimezone(timezone.utc)\n        else:\n            # Assume UTC if no timezone info\n            dt = dt.replace(tzinfo=timezone.utc)\n        \n        # Return milliseconds since epoch\n        timestamp_ms = int(dt.timestamp() * 1000)\n        print(f\"[_parse_rfc3339] Parsed RFC3339 '{time_str}' to {timestamp_ms}ms\", file=sys.stderr)\n        return timestamp_ms\n    except (ValueError, AttributeError) as e:\n        print(f\"[_parse_rfc3339] Failed to parse '{time_str}' as RFC3339: {e}\", file=sys.stderr)\n        return None\n\n\ndef _validate_time_string(value: Any) -\u003e Optional[Union[str, int]]:\n    \"\"\"\n    Validate and return time string for Datadog Events v2 search.\n    Accepts:\n    1. Date math strings: \"now\", \"now-15m\", \"now-1h\", \"now-1d\", etc.\n    2. RFC3339 timestamps: \"2024-01-15T10:30:00Z\", \"2024-01-15T10:30:00+00:00\"\n    \n    Returns:\n    - Date math string as-is (str)\n    - RFC3339 parsed to Unix timestamp in milliseconds (int)\n    - None if invalid\n    \"\"\"\n    if value is None:\n        print(\"[_validate_time_string] Value is None\", file=sys.stderr)\n        return None\n    \n    if not isinstance(value, str):\n        print(f\"[_validate_time_string] Value is not a string: {type(value)}\", file=sys.stderr)\n        return None\n    \n    value = value.strip()\n    if not value:\n        print(\"[_validate_time_string] Value is empty after strip\", file=sys.stderr)\n        return None\n    \n    # Check for date math format: \"now\" or \"now-\u003cnumber\u003e\u003cunit\u003e\" or \"now+\u003cnumber\u003e\u003cunit\u003e\"\n    date_math_pattern = r'^now([+-]\\d+[smhdwMy])?$'\n    if re.match(date_math_pattern, value):\n        print(f\"[_validate_time_string] Valid date math format: {value}\", file=sys.stderr)\n        return value\n    \n    # Try parsing as RFC3339\n    rfc3339_pattern = r'^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}'\n    if re.match(rfc3339_pattern, value):\n        timestamp_ms = _parse_rfc3339(value)\n        if timestamp_ms is not None:\n            return timestamp_ms\n    \n    print(f\"[_validate_time_string] Invalid time format (expected date math like 'now-1h' or RFC3339 like '2024-01-15T10:30:00Z'): {value}\", file=sys.stderr)\n    return None\n\n\ndef _http_post_json(url: str, headers: Dict[str, str], body: Dict[str, Any], timeout_s: int) -\u003e Dict[str, Any]:\n    print(f\"[_http_post_json] Making POST request to: {url}\", file=sys.stderr)\n    print(f\"[_http_post_json] Request body: {json.dumps(body, indent=2)}\", file=sys.stderr)\n    \n    data = json.dumps(body).encode(\"utf-8\")\n    req = urllib.request.Request(url, data=data, headers=headers, method=\"POST\")\n    \n    try:\n        with urllib.request.urlopen(req, timeout=timeout_s) as resp:\n            print(f\"[_http_post_json] Response status: {resp.status}\", file=sys.stderr)\n            raw = resp.read().decode(\"utf-8\")\n            result = json.loads(raw) if raw else {}\n            print(f\"[_http_post_json] Response received with {len(result.get('data', []))} items\", file=sys.stderr)\n            return result\n    except urllib.error.HTTPError as e:\n        print(f\"[_http_post_json] HTTP error {e.code}: {e.reason}\", file=sys.stderr)\n        raw = \"\"\n        try:\n            raw = e.read().decode(\"utf-8\")\n            print(f\"[_http_post_json] Error response body: {raw}\", file=sys.stderr)\n        except Exception:\n            pass\n        raise RuntimeError(f\"Datadog HTTP {e.code}: {raw or e.reason}\") from e\n    except urllib.error.URLError as e:\n        print(f\"[_http_post_json] URL error: {e.reason}\", file=sys.stderr)\n        raise RuntimeError(f\"Datadog request failed: {e.reason}\") from e\n\n\ndef _build_trigger_query() -\u003e str:\n    \"\"\"\n    Build query for monitor alert transition events.\n    Filters for events that transitioned TO alert state specifically.\n    \"\"\"\n    query = \"(source:alert OR sourcecategory:monitor_alert) AND @monitor.transition.transition_type:alert\"\n    print(f\"[_build_trigger_query] Built query: {query}\", file=sys.stderr)\n    return query\n\n\ndef _normalize_event(item: Dict[str, Any], site: str) -\u003e Dict[str, Any]:\n    \"\"\"\n    Extract minimal payload from Events v2 search response items.\n    Returns: service, alertName, expr, timestamp, priority, snap_url, alert_url\n    \n    Args:\n        item: Event item from Datadog API response\n        site: Datadog site domain (e.g., 'datadoghq.com')\n    \"\"\"\n    outer_attrs = item.get(\"attributes\") or {}\n    evt = outer_attrs.get(\"attributes\") if isinstance(outer_attrs, dict) else {}\n    if not isinstance(evt, dict):\n        evt = {}\n\n    monitor = evt.get(\"monitor\") if isinstance(evt.get(\"monitor\"), dict) else {}\n    \n    # Extract monitor.result for snap_url, alert_url and timestamp conversion\n    result = monitor.get(\"result\") if isinstance(monitor.get(\"result\"), dict) else {}\n    \n    # Convert result_ts from seconds to milliseconds\n    result_ts = result.get(\"result_ts\")\n    timestamp_ms = None\n    if isinstance(result_ts, (int, float)):\n        timestamp_ms = int(result_ts * 1000)\n    \n    # Construct full alert_url if it exists\n    alert_url = result.get(\"alert_url\")\n    if alert_url and isinstance(alert_url, str) and alert_url.strip():\n        # Prepend the site domain to create full URL\n        alert_url = f\"https://{site}{alert_url}\"\n        print(f\"[_normalize_event] Constructed full alert_url: {alert_url}\", file=sys.stderr)\n    \n    normalized = {\n        \"service\": evt.get(\"service\"),\n        \"alertName\": monitor.get(\"name\"),\n        \"expr\": monitor.get(\"query\"),\n        \"timestamp\": timestamp_ms,\n        \"priority\": evt.get(\"priority\"),\n        \"snap_url\": result.get(\"snap_url\"),\n        \"alert_url\": alert_url\n    }\n    \n    print(f\"[_normalize_event] Normalized event: alertName={normalized.get('alertName')}, service={normalized.get('service')}, alert_url={normalized.get('alert_url')}\", file=sys.stderr)\n    return normalized\n\n\ndef run(input: dict) -\u003e dict:\n    \"\"\"\n    Input JSON shape:\n      {\n        \"start\": \"now-1h\" or \"2024-01-15T10:30:00Z\",  # date math or RFC3339\n        \"end\": \"now\" or \"2024-01-15T11:30:00Z\",      # date math or RFC3339\n      }\n\n    Output:\n      { \"start\": \"...\", \"end\": \"...\", \"events\": [...] }\n    \"\"\"\n    print(\"[run] Starting Datadog monitor alert events retrieval\", file=sys.stderr)\n    print(f\"[run] Input received: {json.dumps(input, indent=2)}\", file=sys.stderr)\n    \n    # Get credentials from environment variables only\n    site = os.getenv(\"DATADOG_SITE\")\n    if not site or not site.strip():\n        site = \"datadoghq.com\"\n        print(f\"[run] DATADOG_SITE not set, using default: {site}\", file=sys.stderr)\n    else:\n        site = site.strip()\n        print(f\"[run] Using Datadog site from DATADOG_SITE: {site}\", file=sys.stderr)\n    \n    api_key = os.getenv(\"DATADOG_API_KEY\")\n    if api_key:\n        api_key = api_key.strip()\n        print(\"[run] DATADOG_API_KEY found in environment\", file=sys.stderr)\n    else:\n        print(\"[run] DATADOG_API_KEY not found in environment\", file=sys.stderr)\n    \n    app_key = os.getenv(\"DATADOG_APP_KEY\")\n    if app_key:\n        app_key = app_key.strip()\n        print(\"[run] DATADOG_APP_KEY found in environment\", file=sys.stderr)\n    else:\n        print(\"[run] DATADOG_APP_KEY not found in environment\", file=sys.stderr)\n\n    if not api_key or not app_key:\n        error_msg = \"Missing Datadog credentials. Set DATADOG_API_KEY and DATADOG_APP_KEY environment variables.\"\n        print(f\"[run] ERROR: {error_msg}\", file=sys.stderr)\n        return {\"error\": error_msg}\n\n    print(\"[run] Credentials validated successfully\", file=sys.stderr)\n\n    start_raw = input.get(\"start\")\n    end_raw = input.get(\"end\")\n    \n    print(f\"[run] Raw start time: {start_raw}\", file=sys.stderr)\n    print(f\"[run] Raw end time: {end_raw}\", file=sys.stderr)\n    \n    start = _validate_time_string(start_raw)\n    if start is None:\n        start = \"now-15m\"\n        print(f\"[run] Using default start time: {start}\", file=sys.stderr)\n    \n    end = _validate_time_string(end_raw)\n    if end is None:\n        end = \"now\"\n        print(f\"[run] Using default end time: {end}\", file=sys.stderr)\n\n    query = _build_trigger_query()\n\n    url = f\"https://api.{site}/api/v2/events/search\"\n    print(f\"[run] API endpoint: {url}\", file=sys.stderr)\n    \n    headers = {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n        \"DD-API-KEY\": api_key,\n        \"DD-APPLICATION-KEY\": app_key,\n    }\n\n    all_events: List[Dict[str, Any]] = []\n    cursor: Optional[str] = None\n    page_num = 0\n\n    print(\"[run] Starting pagination loop to fetch all events\", file=sys.stderr)\n    \n    # Pull all pages until exhausted\n    while True:\n        page_num += 1\n        print(f\"[run] Fetching page {page_num}...\", file=sys.stderr)\n        \n        body: Dict[str, Any] = {\n            \"filter\": {\n                \"from\": start,\n                \"to\": end,\n                \"query\": query,\n            },\n            \"sort\": \"timestamp\",\n            \"page\": {\"limit\": 1000},\n        }\n        if cursor:\n            body[\"page\"][\"cursor\"] = cursor\n            print(f\"[run] Using cursor for pagination: {cursor[:50]}...\", file=sys.stderr)\n\n        resp = _http_post_json(url, headers=headers, body=body, timeout_s=30)\n\n        data = resp.get(\"data\") or []\n        if isinstance(data, list):\n            print(f\"[run] Page {page_num} returned {len(data)} events\", file=sys.stderr)\n            for item in data:\n                if isinstance(item, dict):\n                    all_events.append(_normalize_event(item, site))\n        else:\n            print(f\"[run] Page {page_num} returned non-list data\", file=sys.stderr)\n\n        meta = resp.get(\"meta\") or {}\n        next_cursor: Optional[str] = None\n        if isinstance(meta, dict):\n            page = meta.get(\"page\") or {}\n            if isinstance(page, dict):\n                next_cursor = page.get(\"after\")\n\n        # stop if no further cursor\n        if not next_cursor or (cursor and next_cursor == cursor):\n            print(f\"[run] No more pages to fetch. Total pages: {page_num}\", file=sys.stderr)\n            break\n\n        cursor = next_cursor\n\n    print(f\"[run] Successfully retrieved {len(all_events)} total events\", file=sys.stderr)\n    \n    # Convert start/end back to string representation for output\n    start_str = str(start) if isinstance(start, int) else start\n    end_str = str(end) if isinstance(end, int) else end\n    \n    result = {\n        \"start\": start_str,\n        \"end\": end_str,\n        \"events\": all_events\n    }\n    \n    print(f\"[run] Returning result with {len(all_events)} events\", file=sys.stderr)\n    return result\n\n\nif __name__ == \"__main__\":\n    print(\"[main] Reading input from stdin\", file=sys.stderr)\n    input_data = json.load(sys.stdin)\n    print(\"[main] Input parsed successfully\", file=sys.stderr)\n    \n    result = run(input_data)\n    \n    print(\"[main] Writing result to stdout\", file=sys.stderr)\n    print(json.dumps(result))\n    print(\"[main] Execution completed\", file=sys.stderr)",
  "environmentVariables": [],
  "inputSchema": {
    "properties": {
      "end": {
        "description": "End time in date math format (e.g., 'now') OR RFC3339 format (e.g., '2024-01-15T11:30:00Z', '2024-01-15T11:30:00+00:00')",
        "type": "string"
      },
      "start": {
        "description": "Start time in date math format (e.g., 'now-1h', 'now-15m') OR RFC3339 format (e.g., '2024-01-15T10:30:00Z', '2024-01-15T10:30:00+00:00')",
        "type": "string"
      }
    },
    "required": [
      "start",
      "end"
    ],
    "type": "object"
  },
  "execution": {
    "timeoutSeconds": 30,
    "workingDirectory": "workspace"
  },
  "createdAt": "2025-12-26T06:25:32Z",
  "updatedAt": "2025-12-30T02:24:20Z"
}